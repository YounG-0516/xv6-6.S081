diff --git a/kernel/defs.h b/kernel/defs.h
index 59f7aae..491b9c9 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -92,6 +92,7 @@ int             fork(void);
 int             growproc(int);
 pagetable_t     proc_pagetable(struct proc *);
 void            proc_freepagetable(pagetable_t, uint64);
+void            kpagetable_free(pagetable_t);
 int             kill(int);
 struct cpu*     mycpu(void);
 struct cpu*     getmycpu(void);
@@ -179,6 +180,11 @@ int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
 int             test_pagetable();
+void            vmprint(pagetable_t);
+void            vmrecursion(pagetable_t, int, uint64);
+void            kvmmap_new(pagetable_t, uint64, uint64, uint64, int);
+pagetable_t     vmcreate();
+void            sync_pagetable(pagetable_t, pagetable_t);
 
 // plic.c
 void            plicinit(void);
@@ -194,7 +200,9 @@ void            virtio_disk_intr(void);
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
 
-
+// vmcopyin.c
+int             copyin_new(pagetable_t, char *, uint64, uint64);
+int             copyinstr_new(pagetable_t, char *, uint64, uint64);
 
 // stats.c
 void            statsinit(void);
diff --git a/kernel/exec.c b/kernel/exec.c
index 7b8a524..52bf77a 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -41,6 +41,7 @@ int exec(char *path, char **argv) {
     if (ph.vaddr + ph.memsz < ph.vaddr) goto bad;
     uint64 sz1;
     if ((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0) goto bad;
+    //if (sz1 > PLIC) goto bad;
     sz = sz1;
     if (ph.vaddr % PGSIZE != 0) goto bad;
     if (loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) < 0) goto bad;
@@ -97,6 +98,13 @@ int exec(char *path, char **argv) {
   p->trapframe->sp = sp;          // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
 
+  if(p->pid == 1){
+    vmprint(p->pagetable);
+  }
+
+  //将改变后的进程页表同步
+  sync_pagetable(p->pagetable, p->k_pagetable);
+
   return argc;  // this ends up in a0, the first argument to main(argc, argv)
 
 bad:
@@ -105,6 +113,8 @@ bad:
     iunlockput(ip);
     end_op();
   }
+  //将改变后的进程页表同步
+  sync_pagetable(p->pagetable, p->k_pagetable);
   return -1;
 }
 
diff --git a/kernel/proc.c b/kernel/proc.c
index 292ccb8..566fac8 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -34,9 +34,10 @@ void procinit(void) {
     // guard page.
     char *pa = kalloc();
     if (pa == 0) panic("kalloc");
-    uint64 va = KSTACK((int)(p - proc));
-    kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
-    p->kstack = va;
+    uint64 va = KSTACK((int)(p - proc));  // 计算内核栈所在的虚拟地址
+    kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);  // 在内核页表建立内核栈的映射
+    p->kstack = va;             // 将内核栈的虚拟地址存储于进程控制块
+    p->kstack_pa = (uint64)pa;  // 内核栈的物理地址
   }
   kvminithart();
 }
@@ -111,6 +112,16 @@ found:
     return 0;
   }
 
+  // 每个进程均设置一个独立的内核页表
+  p->k_pagetable = vmcreate();
+  if (p->k_pagetable == 0) {  // 调用失败
+    freeproc(p);
+    release(&p->lock);
+    return 0;
+  }
+
+  kvmmap_new(p->k_pagetable, p->kstack, p->kstack_pa, PGSIZE, PTE_R | PTE_W);
+
   // Set up new context to start executing at forkret,
   // which returns to user space.
   memset(&p->context, 0, sizeof(p->context));
@@ -126,6 +137,7 @@ found:
 static void freeproc(struct proc *p) {
   if (p->trapframe) kfree((void *)p->trapframe);
   p->trapframe = 0;
+  // 释放该进程的共享内核页表
   if (p->pagetable) proc_freepagetable(p->pagetable, p->sz);
   p->pagetable = 0;
   p->sz = 0;
@@ -136,6 +148,34 @@ static void freeproc(struct proc *p) {
   p->killed = 0;
   p->xstate = 0;
   p->state = UNUSED;
+
+  // 将内核页表中次级页表的0-95项置零，避免重复回收
+  pagetable_t pa = (pagetable_t)PTE2PA(p->k_pagetable[0]);
+  for (int i = 0; i < 0x60; i++) {
+    pa[i] = 0;
+  }
+
+  // 释放该进程的独立内核页表
+  if (p->k_pagetable) kpagetable_free(p->k_pagetable);
+  p->k_pagetable = 0;
+
+}
+
+void kpagetable_free(pagetable_t pagetable){
+  for (int i = 0; i < 512; i++) {
+      pte_t pte = pagetable[i];
+      if ((pte & PTE_V) && (pte & (PTE_R | PTE_W | PTE_X)) == 0) {
+        uint64 child = PTE2PA(pte);
+        // 递归释放子页表及其对应页面
+        kpagetable_free((pagetable_t)child);
+        // 释放页表项的使用
+        pagetable[i] = 0;
+      } else if (pte & PTE_V) {   
+        // 释放叶子页表
+        pagetable[i] = 0;
+      }
+    }
+    kfree((void *)pagetable);
 }
 
 // Create a user page table for a given process,
@@ -202,6 +242,9 @@ void userinit(void) {
 
   p->state = RUNNABLE;
 
+  //将改变后的进程页表同步
+  sync_pagetable(p->pagetable, p->k_pagetable);
+
   release(&p->lock);
 }
 
@@ -220,6 +263,10 @@ int growproc(int n) {
     sz = uvmdealloc(p->pagetable, sz, sz + n);
   }
   p->sz = sz;
+
+  //将改变后的进程页表同步
+  sync_pagetable(p->pagetable, p->k_pagetable);
+  
   return 0;
 }
 
@@ -262,6 +309,9 @@ int fork(void) {
 
   np->state = RUNNABLE;
 
+  //将改变后的进程页表同步
+  sync_pagetable(np->pagetable, np->k_pagetable);
+
   release(&np->lock);
 
   return pid;
@@ -430,8 +480,17 @@ void scheduler(void) {
         // before jumping back to us.
         p->state = RUNNING;
         c->proc = p;
+
+        // 切换至该进程对应的独立内核页表
+        w_satp(MAKE_SATP(p->k_pagetable));
+        sfence_vma();
+
+        // 切换上下文
         swtch(&c->context, &p->context);
 
+        // 恢复至全局内核页表
+        kvminithart();
+
         // Process is done running for now.
         // It should have changed its p->state before coming back.
         c->proc = 0;
@@ -442,6 +501,7 @@ void scheduler(void) {
     }
 #if !defined(LAB_FS)
     if (found == 0) {
+      kvminithart();
       intr_on();
       asm volatile("wfi");
     }
diff --git a/kernel/proc.h b/kernel/proc.h
index 9c16ea7..3482283 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -103,4 +103,7 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+  pagetable_t k_pagetable;     //内核独立页表
+  uint64 kstack_pa;            //内核栈的物理地址
 };
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 5fbd4e0..f2c01bc 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -45,6 +45,7 @@ w_mepc(uint64 x)
 #define SSTATUS_UPIE (1L << 4) // User Previous Interrupt Enable
 #define SSTATUS_SIE (1L << 1)  // Supervisor Interrupt Enable
 #define SSTATUS_UIE (1L << 0)  // User Interrupt Enable
+#define SSTATUS_SUM (1L << 18) 
 
 static inline uint64
 r_sstatus()
diff --git a/kernel/vm.c b/kernel/vm.c
index b794885..00b6813 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -316,21 +316,28 @@ int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) {
 // Copy len bytes to dst from virtual address srcva in a given page table.
 // Return 0 on success, -1 on error.
 int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) {
-  uint64 n, va0, pa0;
-
-  while (len > 0) {
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if (pa0 == 0) return -1;
-    n = PGSIZE - (srcva - va0);
-    if (n > len) n = len;
-    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
 
-    len -= n;
-    dst += n;
-    srcva = va0 + PGSIZE;
-  }
-  return 0;
+  int ret;
+  w_sstatus(r_sstatus() | SSTATUS_SUM);
+  ret = copyin_new(pagetable, dst, srcva, len);
+  w_sstatus(r_sstatus() & ~SSTATUS_SUM);
+  return ret;
+
+  // uint64 n, va0, pa0;
+
+  // while (len > 0) {
+  //   va0 = PGROUNDDOWN(srcva);
+  //   pa0 = walkaddr(pagetable, va0);
+  //   if (pa0 == 0) return -1;
+  //   n = PGSIZE - (srcva - va0);
+  //   if (n > len) n = len;
+  //   memmove(dst, (void *)(pa0 + (srcva - va0)), n);
+
+  //   len -= n;
+  //   dst += n;
+  //   srcva = va0 + PGSIZE;
+  // }
+  // return 0;
 }
 
 // Copy a null-terminated string from user to kernel.
@@ -338,38 +345,45 @@ int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) {
 // until a '\0', or max.
 // Return 0 on success, -1 on error.
 int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max) {
-  uint64 n, va0, pa0;
-  int got_null = 0;
-
-  while (got_null == 0 && max > 0) {
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if (pa0 == 0) return -1;
-    n = PGSIZE - (srcva - va0);
-    if (n > max) n = max;
-
-    char *p = (char *)(pa0 + (srcva - va0));
-    while (n > 0) {
-      if (*p == '\0') {
-        *dst = '\0';
-        got_null = 1;
-        break;
-      } else {
-        *dst = *p;
-      }
-      --n;
-      --max;
-      p++;
-      dst++;
-    }
 
-    srcva = va0 + PGSIZE;
-  }
-  if (got_null) {
-    return 0;
-  } else {
-    return -1;
-  }
+  int ret;
+  w_sstatus(r_sstatus() | SSTATUS_SUM);
+  ret = copyinstr_new(pagetable, dst, srcva, max);
+  w_sstatus(r_sstatus() & ~SSTATUS_SUM);
+  return ret;
+
+  // uint64 n, va0, pa0;
+  // int got_null = 0;
+
+  // while (got_null == 0 && max > 0) {
+  //   va0 = PGROUNDDOWN(srcva);
+  //   pa0 = walkaddr(pagetable, va0);
+  //   if (pa0 == 0) return -1;
+  //   n = PGSIZE - (srcva - va0);
+  //   if (n > max) n = max;
+
+  //   char *p = (char *)(pa0 + (srcva - va0));
+  //   while (n > 0) {
+  //     if (*p == '\0') {
+  //       *dst = '\0';
+  //       got_null = 1;
+  //       break;
+  //     } else {
+  //       *dst = *p;
+  //     }
+  //     --n;
+  //     --max;
+  //     p++;
+  //     dst++;
+  //   }
+
+  //   srcva = va0 + PGSIZE;
+  // }
+  // if (got_null) {
+  //   return 0;
+  // } else {
+  //   return -1;
+  // }
 }
 
 // check if use global kpgtbl or not
@@ -378,4 +392,116 @@ int test_pagetable() {
   uint64 gsatp = MAKE_SATP(kernel_pagetable);
   printf("test_pagetable: %d\n", satp != gsatp);
   return satp != gsatp;
-}
\ No newline at end of file
+}
+
+/****************************************task1*******************************************/
+
+void vmprint(pagetable_t pgtbl){
+  printf("page table %p\n", pgtbl);
+  uint64 idx = 0x0000000000000000;
+  vmrecursion(pgtbl, 1, idx);
+}
+
+// 递归函数
+void vmrecursion(pagetable_t pgtbl, int depth, uint64 idx){
+  
+  for (int i = 0; i < 512; i++) {
+    pte_t pte = pgtbl[i];
+
+    char rwxu[4] = "----";
+    
+    // 当前页表项有效
+    if(pte & PTE_V){
+      printf("||");
+
+      // 有效位转换打印
+      if(pte & PTE_R){
+        rwxu[0] = 'r';
+      }
+      if(pte & PTE_W){
+        rwxu[1] = 'w';
+      }
+      if(pte & PTE_X){
+        rwxu[2] = 'x';
+      }
+      if(pte & PTE_U){
+        rwxu[3] = 'u';
+      }
+
+      for(int j=1; j<depth; j++){
+        printf("   ||");
+      }
+
+      //判断当前页表项是否有效且不包含读（PTE_R）、写（PTE_W）和执行（PTE_X）权限
+      if ((pte & (PTE_R | PTE_W | PTE_X)) == 0) {
+        // 当前页表项是一个指向较低级页表的页表项
+        idx = idx + i;
+        idx = idx << 9;
+
+        printf("idx: %d: pa: %p, flags: %s\n", i, PTE2PA(pte), rwxu);
+        uint64 child = PTE2PA(pte);
+        vmrecursion((pagetable_t)child, depth+1, idx);
+        idx = idx >> 9;
+        idx = idx - i;
+      } else {
+        idx = idx + i;
+        idx = idx << 12;
+        printf("idx: %d: va: %p -> pa: %p, flags: %s\n", i, idx, PTE2PA(pte), rwxu);
+        idx = idx >> 12;
+        idx = idx - i;
+      }
+    }
+  }
+}
+
+/****************************************task2*******************************************/
+
+void kvmmap_new(pagetable_t k_pagetable, uint64 va, uint64 pa, uint64 sz, int perm) {
+  if (mappages(k_pagetable, va, sz, pa, perm) != 0) panic("kvmmap_new");
+}
+
+pagetable_t vmcreate(){
+  // 为内核页表分配内存PGSIZE
+  pagetable_t k_pagetable = (pagetable_t)kalloc();
+
+  // 设置页表的初始状态是空的
+  memset(k_pagetable, 0, PGSIZE);
+
+  // 将不同的物理地址映射到对应的虚拟地址
+  // 将UART0的物理地址映射到虚拟地址UART0上，并设置该映射为可读可写权限
+  kvmmap_new(k_pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);
+
+  // virtio mmio disk interface
+  kvmmap_new(k_pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
+
+  // // CLINT
+  // kvmmap(CLINT, CLINT, 0x10000, PTE_R | PTE_W);
+
+  // 将PLIC的物理地址映射到虚拟地址 PLIC 上，并设置该映射为可读可写权限
+  kvmmap_new(k_pagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
+
+  // map kernel text executable and read-only.
+  kvmmap_new(k_pagetable, KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);
+
+  // map kernel data and the physical RAM we'll make use of.
+  kvmmap_new(k_pagetable, (uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);
+
+  // map the trampoline for trap entry/exit to
+  // the highest virtual address in the kernel.
+  kvmmap_new(k_pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
+
+  return k_pagetable;
+}
+
+/****************************************task3*******************************************/
+
+ void sync_pagetable(pagetable_t user_pagetable, pagetable_t kernel_pagetable){
+
+  pagetable_t user_pa = (pagetable_t)PTE2PA(user_pagetable[0]);
+  pagetable_t kernel_pa = (pagetable_t)PTE2PA(kernel_pagetable[0]);
+
+  for(int i=0; i<0x60; i++){
+    // 将用户页表复制到内核页表中
+    kernel_pa[i] = user_pa[i];
+  }
+ }
\ No newline at end of file
